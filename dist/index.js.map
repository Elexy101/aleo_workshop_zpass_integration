{"version":3,"sources":["../src/interfaces/index.ts","../src/errors/index.ts","../src/core/createAleoWorker.ts","../src/index.ts","../src/core/sdk.ts"],"sourcesContent":["import { HashAlgorithm } from 'zpass-credential-signer';\nimport { OfflineQuery } from '@provablehq/wasm';\n\nexport { HashAlgorithm };\n\nexport interface SDKOptions {\n    privateKey: string;\n    host?: string;\n    network: 'mainnet' | 'testnet';\n}\n\nexport interface SignCredentialOptions {\n    data: { [key: string]: string };\n    hashType: HashAlgorithm;\n    privateKey?: string;\n}\n\nexport interface ProveOffChainOptions {\n    localProgram: string;\n    functionName: string;\n    inputs: string[];\n    offlineQuery?: OfflineQuery;\n}\n\nexport interface VerifyOnChainOptions {\n    transactionId: string;\n    url?: string;\n    network: 'mainnet' | 'testnet';\n} \n\nexport interface VerifyOffChainOptions {\n    execution: string;\n    program: string;\n    functionName: string;\n    inputs?: string[];\n    verifyingKey?: string;\n    url?: string;\n    network: 'mainnet' | 'testnet';\n}\n\nexport interface OnChainOptions {\n    programName: string;\n    functionName: string;\n    privateFee: boolean;\n    inputs: string[];\n    fee: number;\n    feeRecord?: string;\n}\n","export class SDKError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'SDKError';\n    }\n} ","import { wrap } from \"comlink\";\n\nlet singletonWorker: ReturnType<typeof wrap>;\n\ninterface CreateAleoWorkerOptions {\n    url: string;\n    baseUrl?: string;\n}\n\nconst createAleoWorker = ({url, baseUrl}: CreateAleoWorkerOptions) => {\n    if (!singletonWorker) {\n        const worker = new Worker(new URL(url, baseUrl), {\n            type: \"module\",\n        });\n\n        worker.onerror = function(event) {\n            console.error(\"Error in worker: \" + event?.message);\n        };\n\n        singletonWorker = wrap(worker);\n    }\n    return singletonWorker;\n};\n\nexport { createAleoWorker };","export type { \n    SDKOptions,\n    SignCredentialOptions,\n    OnChainOptions,\n    VerifyOnChainOptions\n} from './interfaces';\nexport { HashAlgorithm } from './interfaces';\nexport { SDKError } from './errors';\nexport { createAleoWorker } from './core/createAleoWorker';\nexport { expose } from 'comlink';\nexport { ZPassSDK } from './core/sdk';\nexport type { OutputJSON } from './core/sdk';","import * as wasm from 'zpass-credential-signer';\nimport { SDKError } from '../errors';\nimport { \n    SDKOptions, \n    SignCredentialOptions,  \n    VerifyOnChainOptions,\n    ProveOffChainOptions,\n    VerifyOffChainOptions,\n    OnChainOptions,\n} from '../interfaces';\nimport * as mainnetSDK from '@provablehq/sdk/mainnet.js';\nimport * as testnetSDK from '@provablehq/sdk/testnet.js';\n\nexport type OutputJSON = mainnetSDK.OutputJSON | testnetSDK.OutputJSON;\n\nexport class ZPassSDK {\n    private programManager!: mainnetSDK.ProgramManager | testnetSDK.ProgramManager;\n    private keyProvider!: mainnetSDK.AleoKeyProvider | testnetSDK.AleoKeyProvider;\n    private recordProvider!: mainnetSDK.NetworkRecordProvider | testnetSDK.NetworkRecordProvider;\n    private networkClient!: mainnetSDK.AleoNetworkClient | testnetSDK.AleoNetworkClient;\n    private lastProgram!: string | null;\n    private network!: wasm.Network;\n    private sdk: typeof mainnetSDK | typeof testnetSDK;\n\n    public async getSDKModules(): Promise<{\n        Account: typeof mainnetSDK.Account | typeof testnetSDK.Account,\n        OfflineQuery: typeof mainnetSDK.OfflineQuery | typeof testnetSDK.OfflineQuery,\n        initThreadPool: typeof mainnetSDK.initThreadPool | typeof testnetSDK.initThreadPool\n    }> {\n        return {\n            Account: this.sdk.Account,\n            OfflineQuery: this.sdk.OfflineQuery,\n            initThreadPool: this.sdk.initThreadPool\n        };\n    }\n\n    constructor({ privateKey, host, network = 'mainnet' }: SDKOptions) {\n        if (typeof WebAssembly === 'undefined') {\n            throw new SDKError('WebAssembly is not supported in this environment. ZPassSDK requires WebAssembly support.');\n        }\n\n        if (!privateKey.startsWith('APrivateKey1')) {\n            throw new SDKError('Invalid private key format. Private key must start with \"APrivateKey1\"');\n        }\n\n        if (network === 'mainnet') {\n            this.sdk = mainnetSDK;\n            const { Account, ProgramManager, AleoKeyProvider, NetworkRecordProvider, AleoNetworkClient } = this.sdk;\n            try {\n                const account = new Account({privateKey});\n                host = host ? host : 'https://api.explorer.provable.com/v1';\n                this.programManager = new ProgramManager(host);\n                this.networkClient = new AleoNetworkClient(host, {\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    }\n                });\n                this.keyProvider = new AleoKeyProvider();\n                this.recordProvider = new NetworkRecordProvider(account, this.networkClient);\n                this.programManager.setAccount(account);\n                this.programManager.setKeyProvider(this.keyProvider);\n                this.programManager.setRecordProvider(this.recordProvider);\n                this.lastProgram = null;\n                this.network = wasm.Network.Mainnet;\n            } catch (error: unknown) {\n                const message = error instanceof Error ? error.message : 'unknown error';\n                throw new SDKError(`Error initializing SDK: ${message}`);\n            }\n        } else {\n            this.sdk = testnetSDK;\n            const { Account, ProgramManager, AleoKeyProvider, NetworkRecordProvider, AleoNetworkClient } = this.sdk;\n            try {\n                const account = new Account({privateKey});\n                host = host ? host : 'https://api.explorer.provable.com/v1';\n                this.programManager = new ProgramManager(host);\n                this.networkClient = new AleoNetworkClient(host, {\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    }\n                });\n                this.keyProvider = new AleoKeyProvider();\n                this.recordProvider = new NetworkRecordProvider(account, this.networkClient);\n                this.programManager.setAccount(account);\n                this.programManager.setKeyProvider(this.keyProvider);\n                this.programManager.setRecordProvider(this.recordProvider);\n                this.lastProgram = null;\n                this.network = wasm.Network.Testnet;\n            } catch (error: unknown) {\n                const message = error instanceof Error ? error.message : 'unknown error';\n                throw new SDKError(`Error initializing SDK: ${message}`);\n            }\n        }\n    }\n\n    public async getMerkleRoot(inputs: string[]): Promise<string> {\n        const root = wasm.get_merkle_root(inputs, this.network);\n        return root;\n    }\n\n    public async getMerkleTree(inputs: string[]): Promise<string> {\n        const proof = wasm.get_merkle_tree(inputs, this.network);\n        return proof;\n    }\n\n    public async getMerkleProof(inputs: string[], index: number): Promise<string[]> {\n        const proof = wasm.get_merkle_proof(inputs, index, this.network);\n        return proof;\n    }\n\n    public async getLeavesHashes(inputs: string[]): Promise<string[]> {\n        const hashes = wasm.hash_to_fields_size_8(inputs, this.network);\n        return hashes;\n    }\n\n    public async signMerkleRoot(root: string): Promise<string> {\n        const privateKey = this.programManager.account?.privateKey()?.to_string();\n        if (!privateKey) {\n            throw new SDKError(\"Private key is not available\");\n        }\n        const proof = wasm.sign_merkle_root(privateKey, root, this.network);\n        return proof;\n    }\n\n    public setNewHost(host: string) {\n        this.programManager.setHost(host);\n    }\n\n    public async signCredential(options: SignCredentialOptions): Promise<{signature: string, hash: string}> {\n        const { data, hashType, privateKey } = options;\n        const msg = new wasm.SignInboundMessage(data);\n        const privateKeyToUse = privateKey ?? this.programManager.account?.privateKey()?.to_string();\n        if (!privateKeyToUse) {\n            throw new SDKError(\"Private key is not available\");\n        }\n        const { signature, hash } = wasm.sign_message(privateKeyToUse, msg, hashType, this.network);\n        return {\n            signature,\n            hash,\n        };\n    }\n\n    public async issueZPass(options: OnChainOptions): Promise<string> {\n        return this.onChainInteract(options);\n    }\n\n    public async getZPassRecord(transactionId: string): Promise<string> {\n        const { RecordCiphertext } = this.sdk;\n        const tx = await this.networkClient.getTransaction(transactionId);\n        const outputs = tx.execution?.transitions?.[0].outputs;\n        if (!outputs) {\n            throw new SDKError(\"No outputs found in transaction\");\n        }\n        \n        const recordOutput = outputs.find((output: mainnetSDK.OutputJSON | testnetSDK.OutputJSON) => output.type === 'record');\n        if (!recordOutput) {\n            throw new SDKError(\"No record found in transaction outputs\");\n        }\n        const record = recordOutput.value;\n\n        const recordCiphertext = RecordCiphertext.fromString(record);\n        const viewKey = this.programManager.account?.viewKey();\n        if (!viewKey) {\n            throw new SDKError(\"View key is not available\");\n        }\n        const recordPlaintext = recordCiphertext.decrypt(viewKey);\n\n        return recordPlaintext.toString();\n    }\n\n    public async proveOnChain(options: OnChainOptions): Promise<string> {\n        return this.onChainInteract(options);\n    }\n\n    public async proveOffChain(options: ProveOffChainOptions): Promise<{outputs: string[], execution: string, verifyingKey: string}> {\n        const { localProgram, functionName, inputs, offlineQuery } = options;\n        const { AleoKeyProviderParams } = this.sdk;\n        \n        // Ensure the program is valid and that it contains the function specified\n        const program = this.programManager.createProgramFromSource(localProgram);\n        const program_id = program.id();\n        if (!program.hasFunction(functionName)) {\n          throw `Program ${program_id} does not contain function ${functionName}`;\n        }\n        const cacheKey = `${program_id}:${functionName}`;\n\n        // Get the program imports\n        const imports = await this.networkClient.getProgramImports(localProgram);\n\n        // Get the proving and verifying keys for the function\n        if (this.lastProgram !== localProgram) {\n          const keys = await this.programManager.synthesizeKeys(\n            localProgram,\n            functionName,\n            inputs,\n            this.programManager.account?.privateKey()\n          );\n          this.keyProvider.cacheKeys(cacheKey, keys);\n          this.lastProgram = localProgram;\n        }\n\n        // Pass the cache key to the execute function\n        const keyParams = new AleoKeyProviderParams({\n          cacheKey: cacheKey,\n        });\n\n        // Execute the function locally\n        const response = await this.programManager.run(\n          localProgram,\n          functionName,\n          inputs,\n          true,\n          imports,\n          keyParams,\n          this.keyProvider.getKeys(cacheKey)[0],\n          this.keyProvider.getKeys(cacheKey)[1],\n          this.programManager.account?.privateKey(),\n          offlineQuery\n        );\n        const outputs = response.getOutputs();\n        const execution = response.getExecution()?.toString();\n        const verifyingKey = response.getVerifyingKey()?.toString();\n\n        return {\n            outputs,\n            execution: execution!,\n            verifyingKey,\n        };\n    }\n\n    public static async verifyOnChain(options: VerifyOnChainOptions): Promise<{hasExecution: boolean, outputs: mainnetSDK.OutputJSON[] | testnetSDK.OutputJSON[]}> {\n        const { transactionId, url, network } = options;\n        let sdkModule = network === 'mainnet' ? mainnetSDK : testnetSDK;\n        const { AleoNetworkClient } = sdkModule;\n\n        const baseUrl = !url ? \"https://api.explorer.provable.com/v1\" : url;\n        const networkClient = new AleoNetworkClient(baseUrl, {\n            headers: {\n                \"Content-Type\": \"application/json\"\n            }\n        });\n\n        const transaction = await networkClient.getTransaction(transactionId);\n        console.log(\"Transaction:\", transaction);\n        const hasExecution = transaction.type === \"execute\" ? true : false;\n        const outputs = transaction.execution?.transitions?.[0].outputs;\n        return {\n            hasExecution,\n            outputs: outputs ?? [],\n        };\n    }\n\n    public static async verifyOffChain(options: VerifyOffChainOptions): Promise<boolean> {\n        const { execution, program, functionName, inputs, verifyingKey, url, network } = options;\n        let sdkModule = network === 'mainnet' ? mainnetSDK : testnetSDK;\n        const { ProgramManager, AleoKeyProvider, verifyFunctionExecution, FunctionExecution, VerifyingKey, Program } = sdkModule;\n        \n        // Validate that at least one of inputs or verifyingKey is provided\n        if (!inputs && !verifyingKey) {\n            throw new SDKError(\"Either inputs or verifyingKey must be provided\");\n        }\n\n        let verifyingKeyToUse: string;\n        \n        if (!verifyingKey && inputs) {\n            // Branch 1: Only use inputs if verifyingKey is not provided\n            const programManager = new ProgramManager(url, new AleoKeyProvider());\n            const keys = await programManager.synthesizeKeys(\n                program,\n                functionName,\n                inputs,\n            );\n            verifyingKeyToUse = keys[1].toString();\n        } else {\n            // Branch 2: Priority branch - use verifyingKey if provided\n            verifyingKeyToUse = verifyingKey!;\n        }\n\n        const res = verifyFunctionExecution(\n            FunctionExecution.fromString(execution),\n            VerifyingKey.fromString(verifyingKeyToUse),\n            Program.fromString(program),\n            functionName\n        );\n        return res;\n    }\n\n    async onChainInteract(options: OnChainOptions): Promise<string> {\n        const { programName, functionName, inputs, privateFee, fee, feeRecord } = options;\n        const { AleoKeyProviderParams } = this.sdk;\n        const program = await this.networkClient.getProgram(programName);\n        const cacheKey = `${programName}:${functionName}`;\n\n        if (this.lastProgram !== program) {\n            const keys = await this.programManager.synthesizeKeys(\n                program,\n                functionName,\n                inputs,\n                this.programManager.account?.privateKey()\n            );\n            this.keyProvider.cacheKeys(cacheKey, keys);\n            this.lastProgram = program;\n        }\n\n        const keyParams = new AleoKeyProviderParams({\n            cacheKey: cacheKey,\n        });\n\n        const transaction = await this.programManager.buildExecutionTransaction({\n            programName,\n            functionName,\n            fee,\n            privateFee,\n            inputs,\n            feeRecord,\n            program,\n            keySearchParams: keyParams,\n            provingKey: this.keyProvider.getKeys(cacheKey)[0],\n            verifyingKey: this.keyProvider.getKeys(cacheKey)[1],\n        });\n\n        await this.networkClient.submitTransaction(transaction);\n\n        return transaction.id();\n    }\n} \n"],"mappings":"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","names":[]}